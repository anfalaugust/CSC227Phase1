package CSC227_Phase1;
import java.util.*;


public class ProcessSchedulingSimulator {

	// Inner Process structure
	static class Process {
	String ID;
	int Priority, ArrivalTime, BurstTime, RemainingTime , CompletionTime ;
	int StartTime = -1;

	Process(String ID, int ArrivalTime, int BurstTime, int Priority) {
	this.ID = ID;
	this.Priority = Priority;
	this.ArrivalTime = ArrivalTime;
	this.BurstTime = BurstTime;
	this.RemainingTime = RemainingTime;
	}
	}

	// ===== MAIN METHOD =====
	public static void main(String[] args) {
	Scanner input = new Scanner(System.in);
	List<Process> Processes = new ArrayList<>();

	System.out.print("Enter number of processes: ");
	int NumOfProcesses = input.nextInt();

	for (int i = 0; i < NumOfProcesses; i++) {
	System.out.println("\n Enter Priority, Arrival time and Burst time for P" + (i + 1));
	System.out.print("Priority (lower = higher priority): ");
	int Priority = input.nextInt();
	System.out.print("Arrival time: ");
	int ArrivalTime = input.nextInt();
	System.out.print("Burst time: ");
	int BurstTime = input.nextInt();
	Processes.add(new Process("P" + (i + 1), ArrivalTime, BurstTime, Priority));
	}

	System.out.print("\n Enter The time quantum for Round Robin: ");
	int Quantum = input.nextInt();
	input.close();

	// Run both scheduling algorithms
	priorityWithRR(Processes, Quantum);
	fcfs(Processes);
	}

	// ===== PRIORITY WITH ROUND ROBIN =====
	public static void priorityWithRR(List<Process> original, int quantum) {
	List<Process> processes = new ArrayList<>();
	for (Process p : original)
	processes.add(new Process(p.id, p.arrivalTime, p.burstTime, p.priority));

	int time = 0;
	List<Process> completed = new ArrayList<>();

	System.out.println("\n===== Priority Queue with Round Robin =====");
	System.out.println("Time\tProcess");

	Queue<Process> readyQueue = new LinkedList<>();

	while (completed.size() < processes.size()) {
	// Add newly arrived processes
	for (Process p : processes)
	if (p.arrivalTime == time && !readyQueue.contains(p) && p.remainingTime > 0)
	readyQueue.add(p);

	// Find the highest priority currently in ready queue
	int highestPriority = Integer.MAX_VALUE;
	for (Process p : readyQueue)
	if (p.priority < highestPriority)
	highestPriority = p.priority;

	// Filter those with highest priority
	List<Process> samePriorityList = new ArrayList<>();
	for (Process p : readyQueue)
	if (p.priority == highestPriority)
	samePriorityList.add(p);

	if (!samePriorityList.isEmpty()) {
	Process current = samePriorityList.get(0); // Round Robin order
	if (current.startTime == -1)
	current.startTime = time;

	int execTime = Math.min(current.remainingTime, quantum);
	int start = time;

	for (int i = 0; i < execTime; i++) {
	time++;
	current.remainingTime--;

	// Add new arrivals during execution
	for (Process p : processes)
	if (p.arrivalTime == time && !readyQueue.contains(p) && p.remainingTime > 0)
	readyQueue.add(p);

	// Check preemption by higher-priority process
	int minPriority = current.priority;
	for (Process p : readyQueue)
	if (p != current && p.remainingTime > 0 && p.priority < minPriority)
	minPriority = p.priority;

	if (minPriority < current.priority)
	break; // preempt
	}

	int end = time;
	System.out.println(start + "-" + end + " " + current.id);

	if (current.remainingTime == 0) {
	current.completionTime = end;
	completed.add(current);
	readyQueue.remove(current);
	} else {
	// Move to end of queue (RR rotation)
	readyQueue.remove(current);
	readyQueue.add(current);
	}
	} else {
	time++; // idle
	}
	}

	displayMetrics(completed);
	}

	// ===== FIRST-COME FIRST-SERVED =====
	public static void fcfs(List<Process> OriginalProcesses) {
	List<Process> processes = new ArrayList<>();
	List<Process> completed = new ArrayList<>();

	for (Process p : OriginalProcesses)
	processes.add(new Process(p.ID, p.ArrivalTime, p.BurstTime, p.Priority));

	processes.sort(Comparator.comparingInt(p -> p.ArrivalTime));

	System.out.println("\n===== First-Come First-Served (FCFS) =====");
	System.out.println("Time\tProcess");

	int Time = 0;

	for (Process p : processes) {
	if (Time < p.ArrivalTime)
	Time = p.ArrivalTime;

	int StartTime = Time;
	int FinishTime = Time + p.BurstTime;
	Time = FinishTime;
	p.CompletionTime = FinishTime;
	completed.add(p);
	System.out.println(StartTime + "-" + FinishTime + " " + p.ID);
	}

	displayMetrics(completed);
	}

	// ===== METRICS =====
	public static void displayMetrics(List<Process> completed) {
	double totalTAT = 0, totalWT = 0;

	for (Process p : completed) {
	int tat = p.completionTime - p.arrivalTime;
	int wt = tat - p.burstTime;
	totalTAT += tat;
	totalWT += wt;
	}

	System.out.printf("Average Turnaround Time: %.2f%n", totalTAT / completed.size());
	System.out.printf("Average Waiting Time: %.2f%n", totalWT / completed.size());
	System.out.println("CPU Utilization: ");
	}
}

