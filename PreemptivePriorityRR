public class PreemptivePriorityRR {
// ===== PRIORITY WITH ROUND ROBIN =====
	public static void priorityWithRR(List<Process> original, int quantum) {
	List<Process> processes = new ArrayList<>();
	for (Process p : original)
	processes.add(new Process(p.id, p.arrivalTime, p.burstTime, p.priority));

// Now I have copy of all the original processes

	int time = 0;
	List<Process> completed = new ArrayList<>();

// I created a list of the completed processes

	System.out.println("\n===== Priority Queue with Round Robin =====");
	System.out.println("Time\tProcess");

	Queue<Process> readyQueue = new LinkedList<>();

// I created a queue to process the processes according to its priority

	while (completed.size() < processes.size()) {
	// Add newly arrived processes
	for (Process p : processes)
	if (p.arrivalTime == time && !readyQueue.contains(p) && p.remainingTime > 0)
	readyQueue.add(p);

	// Find the highest priority currently in ready queue
	int highestPriority = Integer.MAX_VALUE;
	for (Process p : readyQueue)
	if (p.priority < highestPriority)
	highestPriority = p.priority;

	// Filter those with highest priority
	List<Process> samePriorityList = new ArrayList<>();
	for (Process p : readyQueue)
	if (p.priority == highestPriority)
	samePriorityList.add(p);

	if (!samePriorityList.isEmpty()) {
	Process current = samePriorityList.get(0); // Round Robin order
	if (current.startTime == -1)
	current.startTime = time;

	int execTime = Math.min(current.remainingTime, quantum);
	int start = time;

	for (int i = 0; i < execTime; i++) {
	time++;
	current.remainingTime--;




}
