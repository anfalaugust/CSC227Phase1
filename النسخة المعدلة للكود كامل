package ProcessSchedulingSimulator;
import java.util.*;

public class test {
	
	// Inner Process structure
		static class Process {
		String ID;
		int Priority, ArrivalTime, BurstTime, RemainingTime , CompletionTime ;
		int StartTime = -1;

		Process(String ID, int ArrivalTime, int BurstTime, int Priority) {
		this.ID = ID;
		this.Priority = Priority;
		this.ArrivalTime = ArrivalTime;
		this.BurstTime = BurstTime;
		this.RemainingTime =BurstTime;
		}
		}


	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner input = new Scanner(System.in);
		List<Process> Processes = new ArrayList<>();

		System.out.print("Enter number of processes: ");
		int NumOfProcesses = input.nextInt();

		for (int i = 0; i < NumOfProcesses; i++) {
		System.out.println("\n Enter Priority, Arrival time and Burst time for P" + (i + 1));
		System.out.print("Priority (lower = higher priority): ");
		int Priority = input.nextInt();
		System.out.print("Arrival time: ");
		int ArrivalTime = input.nextInt();
		System.out.print("Burst time: ");
		int BurstTime = input.nextInt();
		Processes.add(new Process("P" + (i + 1), ArrivalTime, BurstTime, Priority));
		}

		System.out.print("\n Enter The time quantum for Round Robin: ");
		int Quantum = input.nextInt();
		input.close();

		// Run both scheduling algorithms
		priorityWithRR(Processes, Quantum);
		FCFS(Processes);
	}

	public static void priorityWithRR(List<Process> original, int Quantum) {
		List<Process> processes = new ArrayList<>();
		for (Process p : original)
		processes.add(new Process(p.ID, p.ArrivalTime, p.BurstTime, p.Priority));

		int time = 0;
		List<Process> completed = new ArrayList<>();

		System.out.println("\n===== Priority Queue with Round Robin =====");
		System.out.println("Time\tProcess");

		Queue<Process> readyQueue = new LinkedList<>();

		while (completed.size() < processes.size()) {
		// Add newly arrived processes
		for (Process p : processes)
		if (p.ArrivalTime == time && !readyQueue.contains(p) && p.RemainingTime > 0)
		readyQueue.add(p);

		// Find the highest priority currently in ready queue
		int highestPriority = Integer.MAX_VALUE;
		for (Process p : readyQueue)
		if (p.Priority < highestPriority)
		highestPriority = p.Priority;

		// Filter those with highest priority
		List<Process> samePriorityList = new ArrayList<>();
		for (Process p : readyQueue)
		if (p.Priority == highestPriority)
		samePriorityList.add(p);

		if (!samePriorityList.isEmpty()) {
		Process current = samePriorityList.get(0); // Round Robin order
		if (current.StartTime == -1)
		current.StartTime = time;

		int execTime = Math.min(current.RemainingTime, Quantum);
		int start = time;

		for (int i = 0; i < execTime; i++) {
		time++;
		current.RemainingTime--;

		// Add new arrivals during execution
		for (Process p : processes)
		if (p.ArrivalTime == time && !readyQueue.contains(p) && p.RemainingTime > 0)
		readyQueue.add(p);

		// Check preemption by higher-priority process
		int minPriority = current.Priority;
		for (Process p : readyQueue)
		if (p != current && p.RemainingTime > 0 && p.Priority < minPriority)
		minPriority = p.Priority;

		if (minPriority < current.Priority)
		break; // preempt
		}

		int end = time;
		System.out.printf("%-8s %s%n", start + "-" + end, current.ID);


		if (current.RemainingTime == 0) {
		current.CompletionTime = end;
		completed.add(current);
		readyQueue.remove(current);
		} else {
		// Move to end of queue (RR rotation)
		readyQueue.remove(current);
		readyQueue.add(current);
		}
		} else {
		time++; // idle
		}
		}

		displayMetrics(completed);
		}
	// ===== FIRST-COME FIRST-SERVED =====
		public static void FCFS(List<Process> OriginalProcesses) {
		List<Process> processes = new ArrayList<>();
		List<Process> completed = new ArrayList<>();

		for (Process p : OriginalProcesses)
		processes.add(new Process(p.ID, p.ArrivalTime, p.BurstTime, p.Priority));

		processes.sort(Comparator.comparingInt(p -> p.ArrivalTime));

		System.out.println("\n===== First-Come First-Served (FCFS) =====");
		System.out.println("Time\tProcess");

		int Time = 0;

		for (Process p : processes) {
		if (Time < p.ArrivalTime)
		Time = p.ArrivalTime;

		int StartTime = Time;
		int FinishTime = Time + p.BurstTime;
		Time = FinishTime;
		p.CompletionTime = FinishTime;
		completed.add(p);
		System.out.printf("%-8s %s%n", StartTime + "-" + FinishTime, p.ID);

		}

		displayMetrics(completed);
		}
		
		// ===== METRICS =====
		public static void displayMetrics(List<Process> completed) {
		double totalTAT = 0, totalWT = 0;

		for (Process p : completed) {
		int tat = p.CompletionTime - p.ArrivalTime;
		int wt = tat - p.BurstTime;
		totalTAT += tat;
		totalWT += wt;
		}

		System.out.printf("Average Turnaround Time: %.2f%n", totalTAT / completed.size());
		System.out.printf("Average Waiting Time: %.2f%n", totalWT / completed.size());
		System.out.println("CPU Utilization: ");
		}
	}
		
